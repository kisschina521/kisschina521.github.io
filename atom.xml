<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Celtics_Super_Fan</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kisschina521.github.io/"/>
  <updated>2019-03-10T07:08:06.783Z</updated>
  <id>https://kisschina521.github.io/</id>
  
  <author>
    <name>李小乾</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>进程操作浅析（一）</title>
    <link href="https://kisschina521.github.io/2019/03/10/%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://kisschina521.github.io/2019/03/10/进程操作浅析（一）/</id>
    <published>2019-03-10T07:08:06.000Z</published>
    <updated>2019-03-10T07:08:06.783Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>fork函数浅析（一）</title>
    <link href="https://kisschina521.github.io/2019/03/10/fork%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://kisschina521.github.io/2019/03/10/fork函数浅析（一）/</id>
    <published>2019-03-10T06:26:33.000Z</published>
    <updated>2019-03-10T08:53:08.066Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程和程序"><a href="#进程和程序" class="headerlink" title="进程和程序"></a>进程和程序</h3><p>进程是一个可执行程序的实例，下面引用《Linux系统管理手册中》的一段话：</p><p>程序是包含了一系列信息的文件，这些信息描述了如何在运行时创建一个进程，所包括的内容如下：</p><pre><code>1. 二进制格式标识2. 机器语言指令3. 程序入口地址：标识程序开始执行时的起始指令地址4. 数据：程序文件包含的变量初始值和程序使用的字面常量值（字符串）5. 符号表及重定位表：描述程序中函数和变量的位置及名称，可以用来调试和运行时的符号解析（链接）6. 共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要的共享库，以及加载共享库的动态链接器的路径名7. 其他信息</code></pre><p>可以用一个程序来创建许多进程，或者可以反过来说，许多进程运行的可以是同一程序</p><p>所以现在重新给出进程的定义：进程是由内核定义的抽象的实体，并为该实体分配用以执行程序的各项系统资源，从内核角度来看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。</p><p><img src="/2019/03/10/fork函数浅析（一）/Users\李飞飞\AppData\Roaming\Typora\typora-user-images\1552207985567.png" alt="1552207985567"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;进程和程序&quot;&gt;&lt;a href=&quot;#进程和程序&quot; class=&quot;headerlink&quot; title=&quot;进程和程序&quot;&gt;&lt;/a&gt;进程和程序&lt;/h3&gt;&lt;p&gt;进程是一个可执行程序的实例，下面引用《Linux系统管理手册中》的一段话：&lt;/p&gt;
&lt;p&gt;程序是包含了一系列信息的文
      
    
    </summary>
    
      <category term="Linux系统编程" scheme="https://kisschina521.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Linux系统调用 C/C++" scheme="https://kisschina521.github.io/tags/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-C-C/"/>
    
  </entry>
  
  <entry>
    <title>数据和指令</title>
    <link href="https://kisschina521.github.io/2019/03/10/%E6%95%B0%E6%8D%AE%E5%92%8C%E6%8C%87%E4%BB%A4/"/>
    <id>https://kisschina521.github.io/2019/03/10/数据和指令/</id>
    <published>2019-03-09T20:20:47.000Z</published>
    <updated>2019-03-10T05:59:06.496Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> data2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> data3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> data4 = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> data5 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> data6;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> e = <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> g;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在思考上面的代码，哪些是指令，哪些是数据呢？</p><p>data1，data4，e放在数据段，data2，3，5，6，f，g放在 .bss 段，剩下都是指令放在.text段，</p><p>.bss放未初始化的全局变量和静态c变量，以及所有被初始化为0的全局或静态变量，在目标文件中.bss不占实际的空间数据放的就是已初始化的全局变量和静态变量，这部分详细的内容，笔者决定学习深入理解计算机系统之后写一篇博客讨论。</p><p>下面我们来看看一个函数调用会发生什么事情</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int sum(int a, int b)&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    temp = a + b;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 20;</span><br><span class="line">    int c = sum(a,b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">9:        int a = 10;</span><br><span class="line">00401078   mov         dword ptr [ebp-4],0Ah</span><br><span class="line">10:       int b = 20;</span><br><span class="line">0040107F   mov         dword ptr [ebp-8],14h</span><br><span class="line">;以上两句在开辟a，b的空间</span><br><span class="line">11:       int c = sum(a,b);</span><br><span class="line">;然后开始执行这句我们看看发生了什么？</span><br><span class="line">00401086   mov         eax,dword ptr [ebp-8]</span><br><span class="line">;把b的值给eax，然后把eax压栈，由此可以看出，函数调用是从右向左压栈</span><br><span class="line">00401089   push        eax</span><br><span class="line">0040108A   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040108D   push        ecx</span><br><span class="line">0040108E   call        @ILT+10(add) (0040100f)</span><br><span class="line">;重点就是这个call指令，他先保存了下一条指令add的地址，为了将来函数调用完成之后可以继续执行下一条</span><br><span class="line">00401093   add         esp,8</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">2:    int sum(int a, int b)&#123;</span><br><span class="line">;一个函数的调用首先会把ebp的值压栈，因为你栈帧回退的时候，你要回到调用者函数的入口</span><br><span class="line">00401020   push        ebp</span><br><span class="line">00401021   mov         ebp,esp ;mov指令把esp的值给ebp，这样ebp就成了被调用函数的栈底指针</span><br><span class="line">00401023   sub         esp,44h ;sub指令把esp的值减44h，等于为被调用的sum函数开辟了44h的空间大小</span><br><span class="line">00401026   push        ebx</span><br><span class="line">00401027   push        esi</span><br><span class="line">00401028   push        edi</span><br><span class="line">;接下来的操作就是在对这个空间的值进行初始化，可以看到全部赋值为0CCCCCCCCh</span><br><span class="line">00401029   lea         edi,[ebp-44h]</span><br><span class="line">0040102C   mov         ecx,11h</span><br><span class="line">00401031   mov         eax,0CCCCCCCCh</span><br><span class="line">00401036   rep stos    dword ptr [edi]</span><br><span class="line">3:        int temp;</span><br><span class="line">4:        temp = a + b;</span><br><span class="line">00401038   mov         eax,dword ptr [ebp+8]</span><br><span class="line">0040103B   add         eax,dword ptr [ebp+0Ch]</span><br><span class="line">0040103E   mov         dword ptr [ebp-4],eax</span><br><span class="line">5:        return temp;</span><br><span class="line">00401041   mov         eax,dword ptr [ebp-4]</span><br><span class="line">6:    &#125;</span><br><span class="line">;我们来看下栈帧回退的过程</span><br><span class="line">00401044   pop         edi</span><br><span class="line">00401045   pop         esi</span><br><span class="line">00401046   pop         ebx</span><br><span class="line">00401047   mov         esp,ebp</span><br><span class="line">;很粗暴，直接把ebp的值给了esp</span><br><span class="line">00401049   pop         ebp</span><br><span class="line">;pop指令把ebp现在指向的值赋给了ebp，现在ebp指向的值就是main函数栈底地址，所以自然回去了</span><br><span class="line">0040104A   ret</span><br><span class="line">;最后的最后执行了add         esp,8，还是很粗暴的方法，由此产生了一个问题？</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">Get</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> *p = Get(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/*打印*p会不会成功呢，答案是会的，从上面的汇编指令可以看出来，你这个并没有释放空间，只是粗暴的把ebp的值给了esp*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="C/C++" scheme="https://kisschina521.github.io/categories/C-C/"/>
    
    
  </entry>
  
  <entry>
    <title>二级指针和字符串数组和命令行参数</title>
    <link href="https://kisschina521.github.io/2019/02/18/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%92%8C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/"/>
    <id>https://kisschina521.github.io/2019/02/18/二级指针和字符串数组和命令行参数/</id>
    <published>2019-02-18T09:04:32.000Z</published>
    <updated>2019-02-18T15:00:49.781Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>先看以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int ar[10] = &#123;12,23,34,56&#125;;</span><br><span class="line">    sizeof(ar);</span><br><span class="line">    int (&amp;br) [10] = ar;</span><br><span class="line">    int (*p) [10] = &amp;ar;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上三种情况中，数组名都代表数组的类型和大小，在以外的情况中，ar代表首元素的地址，<code>int (&amp;br)[10]</code>代表br是数组ar的一个引用，编译器是这样解释的，br是一个引用，是一个数组类型的引用，数组大小是10，如果不加括号，就会这样解释，开辟十个引用空间，这显然是不合理的，<code>int(*p)[10]</code>也是同样的道理，p是一个指向数组的指针，数组里面有两个属性，一个是存放的类型，一个是数组的大小，在编译时都必须给定。</p><p>除了以上三种情况，数组名都是首元素的地址，他退化成一个指针，并且是一个常性指针，不可以被赋值。</p><p>s与p的差别：</p><p>下面来说说这种<code>int*s[10]</code>这种表示s是一个数组，里面存放了10个int型指针，也就是说对于p来说他开辟4个空间，<code>*p</code>开辟40个空间，对于s来说他开辟40个空间，里面每个元素代表了一个指针，更通俗点来说，p是一个指针，s是一个数组名</p><p>下面来看看图示：</p><p><img src="/2019/02/18/二级指针和字符串数组和命令行参数/test1.png" alt></p><p>有了上面的铺垫，我们来正是探讨二维数组：</p><p><img src="/2019/02/18/二级指针和字符串数组和命令行参数/test2.png" alt></p><p>如果要给ar3的第二个元素赋值<code>*(*(p+2)+1)</code>，相当于<code>p[2][1]</code>，也是相当于这么写<code>*(p[2]+1)</code></p><p> 现在我们再来看一个例子，这个就有点混了，我尽力向大家解释这个东西</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ar[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">sizeof</span>(ar);<span class="comment">//48</span></span><br><span class="line">    <span class="keyword">int</span> (&amp;br) [<span class="number">3</span>][<span class="number">4</span>] = ar;</span><br><span class="line">    <span class="keyword">int</span> (*p) [<span class="number">3</span>][<span class="number">4</span>] = &amp;ar;<span class="comment">//p+1加48个字节</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> (*s) [<span class="number">4</span>] = ar;<span class="comment">//ar+1，加一个数组的大小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最开始的三种情况就回到了我们最开始讨论的那三个情况，ar代表了数组的类型和大小，第4个ar代表了数组的首元素的地址，对于一个二维数组来说，他的首元素代表的就是一个一维数组，所以s+1指向了ar[1]，我们去看汇编源码的时候可以清楚的看到，二维数组也是由一维数组构造的。 ，同理，三维数组也是由二维数组组成的，。</p><p>现在我们来测试一个例子，来看看大家到底有没有理解这块的知识：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ar[<span class="number">5</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>(*p)[<span class="number">2</span>] = &amp;ar[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> *s = ar[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,p[<span class="number">1</span>][<span class="number">3</span>],s[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果会是多少呢？</p><p><code>8,6</code></p><p>因为p是指向一个二维数组第二个元素的地址，所以<code>p[1][3]</code>相当于<code>*((*p+1)+3)</code>，s这个呢相当于<code>*s+3</code>加了3个空间。</p><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;二维数组&quot;&gt;&lt;a href=&quot;#二维数组&quot; class=&quot;headerlink&quot; title=&quot;二维数组&quot;&gt;&lt;/a&gt;二维数组&lt;/h3&gt;&lt;p&gt;先看以下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
      <category term="C/C++" scheme="https://kisschina521.github.io/categories/C-C/"/>
    
    
  </entry>
  
  <entry>
    <title>重新起航</title>
    <link href="https://kisschina521.github.io/2019/02/16/%E9%87%8D%E6%96%B0%E8%B5%B7%E8%88%AA/"/>
    <id>https://kisschina521.github.io/2019/02/16/重新起航/</id>
    <published>2019-02-16T06:34:27.000Z</published>
    <updated>2019-02-16T07:11:07.395Z</updated>
    
    <content type="html"><![CDATA[<p>​    我是个码农，却假装是个程序员，不在浮沙筑高台，不为繁华易匠心，是我的追求，今天是2019年情人节的第二天，我想重新起航。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello world\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    我是个码农，却假装是个程序员，不在浮沙筑高台，不为繁华易匠心，是我的追求，今天是2019年情人节的第二天，我想重新起航。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
      <category term="个人随笔" scheme="https://kisschina521.github.io/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>

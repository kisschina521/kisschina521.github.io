<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Celtics_Super_Fan</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kisschina521.github.io/"/>
  <updated>2019-03-17T03:56:54.944Z</updated>
  <id>https://kisschina521.github.io/</id>
  
  <author>
    <name>李小乾</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode链表刷题203_141_83_203_206</title>
    <link href="https://kisschina521.github.io/2019/03/16/LeetCode%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98203-141-83-203-206/"/>
    <id>https://kisschina521.github.io/2019/03/16/LeetCode链表刷题203-141-83-203-206/</id>
    <published>2019-03-16T05:49:31.000Z</published>
    <updated>2019-03-17T03:56:54.944Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表通用数据结构："><a href="#链表通用数据结构：" class="headerlink" title="链表通用数据结构："></a>链表通用数据结构：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="203："><a href="#203：" class="headerlink" title="203："></a>203：</h3><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p><p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/237_example.png" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], node = 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], node = 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>链表至少包含两个节点。</li><li>链表中所有节点的值都是唯一的。</li><li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li><li>不要从你的函数中返回任何结果。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(struct ListNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span>;</span> </span><br><span class="line">     p = node-&gt;next;</span><br><span class="line">     node-&gt;val = p-&gt;val;</span><br><span class="line">     node-&gt;next = p-&gt;next;</span><br><span class="line">     <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法：与下一个节点交换"><a href="#方法：与下一个节点交换" class="headerlink" title="方法：与下一个节点交换"></a>方法：与下一个节点交换</h4><p>从链表里删除一个节点 <code>node</code> 的最常见方法是修改<em>之前</em>节点的 <code>next</code> 指针，使其指向<em>之后</em>的节点。</p><p><img src="https://leetcode-cn.com/media/original_images/237/237_LinkedList.png" alt="img">因为我们无法访问我们想要删除的节点<em>之前</em>的节点，我们始终不能修改该节点的 <code>next</code> 指针。相反，我们必须将想要删除的节点的值替换为它后面节点中的值，然后删除它之后的节点。</p><p><img src="https://leetcode-cn.com/media/original_images/237/237_LinkedList2.png" alt="img"></p><p><img src="https://leetcode-cn.com/media/original_images/237/237_LinkedList3.png" alt="img"></p><p><img src="https://leetcode-cn.com/media/original_images/237/237_LinkedList4.png" alt="img"></p><p>删除的节点不是列表的末尾，所以我们可以保证这种方法是可行的。</p><p>此外我们也能看出一点：<code>当你想删除一个节点的时候，你必须知道前一个节点</code></p><h3 id="141："><a href="#141：" class="headerlink" title="141："></a>141：</h3><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><h4 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h4><p><strong>思路</strong></p><p>我们可以通过检查一个结点此前是否被访问过来判断链表是否为环形链表。常用的方法是使用哈希表。</p><p><strong>算法</strong></p><p>我们遍历所有结点并在哈希表中存储每个结点的引用（或内存地址）。如果当前结点为空结点 <code>null</code>（即已检测到链表尾部的下一个结点），那么我们已经遍历完整个链表，并且该链表不是环形链表。如果当前结点的引用已经存在于哈希表中，那么返回 <code>true</code>（即该链表为环形链表）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    Set&lt;ListNode&gt; nodesSeen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != null) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodesSeen.contains(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodesSeen.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)<em>O</em>(<em>n</em>)， 对于含有 n<em>n</em> 个元素的链表，我们访问每个元素最多一次。添加一个结点到哈希表中只需要花费 O(1)<em>O</em>(1) 的时间。</p></li><li><p>空间复杂度：O(n)<em>O</em>(<em>n</em>)， 空间取决于添加到哈希表中的元素数目，最多可以添加 n<em>n</em> 个元素。 </p></li></ul><hr><h4 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h4><p><strong>思路</strong></p><p>想象一下，两名运动员以不同的速度在环形赛道上跑步会发生什么？</p><p><strong>算法</strong></p><p>通过使用具有 <strong>不同速度</strong> 的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)<em>O</em>(1)。慢指针每次移动一步，而快指针每次移动两步。</p><p>如果列表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 <code>false</code>。</p><p>现在考虑一个环形链表，把慢指针和快指针想象成两个在环形赛道上跑步的运动员（分别称之为慢跑者与快跑者）。而快跑者最终一定会追上慢跑者。这是为什么呢？考虑下面这种情况（记作情况 A） - 假如快跑者只落后慢跑者一步，在下一次迭代中，它们就会分别跑了一步或两步并相遇。</p><p>其他情况又会怎样呢？例如，我们没有考虑快跑者在慢跑者之后两步或三步的情况。但其实不难想到，因为在下一次或者下下次迭代后，又会变成上面提到的情况 A。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == null || head.next == null) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == null || fast.next == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分</strong></p><ul><li><p>时间复杂度：O(n)<em>O</em>(<em>n</em>)， 让我们将 n<em>n</em> 设为链表中结点的总数。为了分析时间复杂度，我们分别考虑下面两种情况。</p><ul><li><strong><em>链表中不存在环：</em></strong><br>快指针将会首先到达尾部，其时间取决于列表的长度，也就是 O(n)<em>O</em>(<em>n</em>)。</li><li><strong><em>链表中存在环：</em></strong><br>我们将慢指针的移动过程划分为两个阶段：非环部分与环形部分：<ol><li>慢指针在走完非环部分阶段后将进入环形部分：此时，快指针已经进入环中 \text{迭代次数} = \text{非环部分长度} = N迭代次数=非环部分长度=<em>N</em></li><li>两个指针都在环形区域中：考虑两个在环形赛道上的运动员 - 快跑者每次移动两步而慢跑者每次只移动一步。其速度的差值为1，因此需要经过 \dfrac{\text{二者之间距离}}{\text{速度差值}}速度差值二者之间距离 次循环后，快跑者可以追上慢跑者。这个距离几乎就是 “\text{环形部分长度 K}环形部分长度 K” 且速度差值为 1，我们得出这样的结论 \text{迭代次数} = \text{近似于}迭代次数=近似于 “\text{环形部分长度 K}环形部分长度 K”.</li></ol></li></ul><p>因此，在最糟糕的情形下，时间复杂度为 O(N+K)<em>O</em>(<em>N</em>+<em>K</em>)，也就是 O(n)<em>O</em>(<em>n</em>)。</p></li><li><p>空间复杂度：O(1)<em>O</em>(1)， 我们只使用了慢指针和快指针两个结点，所以空间复杂度为 O(1)<em>O</em>(1)。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt;node = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(node.contains(head))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span>, *<span class="title">slow</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    slow = head;</span><br><span class="line">    fast = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="83"><a href="#83" class="headerlink" title="83:"></a>83:</h3><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2</span><br><span class="line">输出: 1-&gt;2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure><h4 id="方法：直接法"><a href="#方法：直接法" class="headerlink" title="方法：直接法"></a>方法：直接法</h4><p><strong>算法</strong></p><p>这是一个简单的问题，仅测试你操作列表的结点指针的能力。由于输入的列表已排序，因此我们可以通过将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的，我们更改当前结点的 <code>next</code> 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="keyword">null</span> &amp;&amp; current.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.next.val == current.val) &#123;</span><br><span class="line">            current.next = current.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)<em>O</em>(<em>n</em>)，因为列表中的每个结点都检查一次以确定它是否重复，所以总运行时间为 O(n)<em>O</em>(<em>n</em>)，其中 n<em>n</em> 是列表中的结点数。</li><li>空间复杂度：O(1)<em>O</em>(1)，没有使用额外的空间。</li></ul><p><strong>正确性</strong></p><p>我们可以通过定义<em>循环不变式</em>来证明此代码的正确性。循环不变式是在循环的每次迭代之前和之后为真的条件。在这种情况下，一个帮助我们证明正确性的循环不变式是这样的：</p><blockquote><p>列表中直到指针 <code>current</code> 的所有结点都不包含重复的元素。</p></blockquote><p>我们可以用归纳法证明这种情况确实是循环不变式。在进入循环之前，<code>current</code> 指向列表的头部。因此，列表中直到 <code>current</code> 的部分只包含头部。因此它不能包含任何重复的元素。现在假设<code>current</code> 现在指向列表中的某个结点（但不是最后一个元素），并且列表中直到 <code>current</code> 的部分不包含重复元素。在另一个循环迭代之后，发生两件事之一。</p><ol><li><code>current.next</code> 是 <code>current</code> 的副本。在这种情况下，删除 <code>current.next</code> 中的重复结点，并且<code>current</code>保持指向与之前相同的结点。因此，情况仍然成立；一直到 <code>current</code> 仍然没有重复项。</li><li><code>current.next</code> 不是 <code>current</code> 的副本（并且，因为列表已经排序，<code>current.next</code> 也不是 <code>current</code> <em>之前</em>出现的任何其他元素的副本）。在这种情况下，<code>current</code> 向前移动一步指向 <code>current.next</code>。因此，情况仍然成立；一直到 <code>current</code> 仍然没有重复项。</li></ol><p>在循环的最后一次迭代中，<code>current</code> 必定指向最后一个元素，因为再往后，<code>current.next = null</code>。因此，在循环结束后，直到最后一个元素的所有元素都不包含重复项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">buynode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">p</span> = <span class="title">buynode</span>();</span>;</span><br><span class="line">    p-&gt;next = head;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    ListNode* q;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val == p-&gt;next-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                q = p-&gt;next;</span><br><span class="line">                p-&gt;next = q-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(q);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>p &amp;&amp; p-&gt;next != NULL</code>这句很重要如果前一个条件没有，遍历不到最后一个元素，如果后一个不满足，后一个没有，当<code>p</code>位于最后时<code>q</code>会指向<code>NULL</code>；</p><h3 id="206"><a href="#206" class="headerlink" title="206"></a>206</h3><p>反转一个单链表。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong><br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span>,*<span class="title">q</span>,*<span class="title">r</span>;</span></span><br><span class="line">    p=head;</span><br><span class="line">    q=p-&gt;next;</span><br><span class="line">    head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        r=q-&gt;next;</span><br><span class="line">        q-&gt;next=p;</span><br><span class="line">        p=q;</span><br><span class="line">        q=r;</span><br><span class="line">    &#125;</span><br><span class="line">    head=p;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要在于while里面的条件，要遍历所有的节点，思路其实很简单，把头结点独立出来然后头插，所以要有三个指针，p指向头节点，q指向断开后的链表的第一个节点，r在每次循环开始才指向q的下一个，如果r是在循环的末尾指向下一个，当q是最后一个节点时，r是<code>NULL</code>，<code>q = r; r = q-&gt;next</code>就会运行时崩溃。</p><p>我的错误示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span>,*<span class="title">q</span>,*<span class="title">r</span>;</span></span><br><span class="line">    q = head-&gt;next;</span><br><span class="line">    r = q-&gt;next;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    p = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        q-&gt;next = p;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    head = p;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外这个题还能用递归做：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归写法，就是在入栈是找到链表的最后一个元素，出栈的时候一点点将链表翻转</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head -&gt; next == <span class="literal">NULL</span>)&#123; <span class="comment">// 当 head -&gt; next == node 代表 head 为最后一个节点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">nHead</span> = <span class="title">reverseList</span>(<span class="title">head</span> -&gt; <span class="title">next</span>);</span> <span class="comment">// 循环递归找到最后一个节点</span></span><br><span class="line">    head -&gt; next -&gt; next = head; <span class="comment">// 下一个节点（head —&gt; next）的指向（head —&gt; next -&gt; next），指向本节点(head)</span></span><br><span class="line">    head -&gt; next = <span class="literal">NULL</span>; <span class="comment">// 本节点下一个节点想让它等于空，如果本届点不是原头节点，本次的赋值在下次循环中也会被覆盖</span></span><br><span class="line">    <span class="keyword">return</span> nHead;  <span class="comment">// 将新的头一层层运出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是我这周的刷题，速度有点慢，需要加快！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;链表通用数据结构：&quot;&gt;&lt;a href=&quot;#链表通用数据结构：&quot; class=&quot;headerlink&quot; title=&quot;链表通用数据结构：&quot;&gt;&lt;/a&gt;链表通用数据结构：&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="Leetcode刷题" scheme="https://kisschina521.github.io/categories/Leetcode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="数据结构与算法分析" scheme="https://kisschina521.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>链式队列的基本操作和原理</title>
    <link href="https://kisschina521.github.io/2019/03/10/%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%92%8C%E5%8E%9F%E7%90%86/"/>
    <id>https://kisschina521.github.io/2019/03/10/链式队列的基本操作和原理/</id>
    <published>2019-03-10T15:26:10.000Z</published>
    <updated>2019-03-10T15:26:10.055Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>进程操作浅析（一）</title>
    <link href="https://kisschina521.github.io/2019/03/10/%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://kisschina521.github.io/2019/03/10/进程操作浅析（一）/</id>
    <published>2019-03-10T07:08:06.000Z</published>
    <updated>2019-03-10T07:08:06.783Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>fork函数浅析（一）</title>
    <link href="https://kisschina521.github.io/2019/03/10/fork%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://kisschina521.github.io/2019/03/10/fork函数浅析（一）/</id>
    <published>2019-03-10T06:26:33.000Z</published>
    <updated>2019-03-13T10:46:12.719Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程和程序"><a href="#进程和程序" class="headerlink" title="进程和程序"></a>进程和程序</h3><p>进程是一个可执行程序的实例，下面引用《Linux系统管理手册中》的一段话：</p><p>程序是包含了一系列信息的文件，这些信息描述了如何在运行时创建一个进程，所包括的内容如下：</p><pre><code>1. 二进制格式标识2. 机器语言指令3. 程序入口地址：标识程序开始执行时的起始指令地址4. 数据：程序文件包含的变量初始值和程序使用的字面常量值（字符串）5. 符号表及重定位表：描述程序中函数和变量的位置及名称，可以用来调试和运行时的符号解析（链接）6. 共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要的共享库，以及加载共享库的动态链接器的路径名7. 其他信息</code></pre><p>可以用一个程序来创建许多进程，或者可以反过来说，许多进程运行的可以是同一程序</p><p>所以现在重新给出进程的定义：进程是由内核定义的抽象的实体，并为该实体分配用以执行程序的各项系统资源，从内核角度来看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>);<span class="comment">//得到调用进程id</span></span><br><span class="line"><span class="keyword">pid_t</span> getppid(<span class="keyword">void</span>);<span class="comment">//得到父进程id</span></span><br><span class="line"><span class="keyword">uid_t</span> getuid(<span class="keyword">void</span>);<span class="comment">//得到进程的实际用户id</span></span><br><span class="line"><span class="keyword">uid_t</span> geteuid(<span class="keyword">void</span>);<span class="comment">//调用进程的有效用户id</span></span><br><span class="line"><span class="keyword">gid_t</span> getgid(<span class="keyword">void</span>);<span class="comment">//调用进程的实际组id</span></span><br><span class="line"><span class="keyword">gid_t</span> getegid(<span class="keyword">void</span>);<span class="comment">//调用进程的有效组id</span></span><br></pre></td></tr></table></figure><p>如果子进程的父进程终止，子进程会变成孤儿进程，init进程随机收养该进程</p><h3 id="函数fork"><a href="#函数fork" class="headerlink" title="函数fork"></a>函数fork</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unishd.h&gt;</span><br><span class="line">pid_t fork(void);</span><br><span class="line">/*fork函数被调用一次，但返回两次，子进程返回值是0，父进程返回值是子进程的id，理由是一个进程的子进程有很多，并且没有一个函数使一个进程可以获得所有子进程的进程id，子进程返回0的原因，一个进程只有一个父进程，子进程总可以用getppid得到父进程id，id0总是作为内核交换进程使用，所以子进程id不可能为0*/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;进程和程序&quot;&gt;&lt;a href=&quot;#进程和程序&quot; class=&quot;headerlink&quot; title=&quot;进程和程序&quot;&gt;&lt;/a&gt;进程和程序&lt;/h3&gt;&lt;p&gt;进程是一个可执行程序的实例，下面引用《Linux系统管理手册中》的一段话：&lt;/p&gt;
&lt;p&gt;程序是包含了一系列信息的文
      
    
    </summary>
    
      <category term="Linux系统编程" scheme="https://kisschina521.github.io/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Linux系统调用 C/C++" scheme="https://kisschina521.github.io/tags/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-C-C/"/>
    
  </entry>
  
  <entry>
    <title>数据和指令</title>
    <link href="https://kisschina521.github.io/2019/03/10/%E6%95%B0%E6%8D%AE%E5%92%8C%E6%8C%87%E4%BB%A4/"/>
    <id>https://kisschina521.github.io/2019/03/10/数据和指令/</id>
    <published>2019-03-09T20:20:47.000Z</published>
    <updated>2019-03-10T05:59:06.496Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> data2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> data3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> data4 = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> data5 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> data6;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> e = <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> g;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在思考上面的代码，哪些是指令，哪些是数据呢？</p><p>data1，data4，e放在数据段，data2，3，5，6，f，g放在 .bss 段，剩下都是指令放在.text段，</p><p>.bss放未初始化的全局变量和静态c变量，以及所有被初始化为0的全局或静态变量，在目标文件中.bss不占实际的空间数据放的就是已初始化的全局变量和静态变量，这部分详细的内容，笔者决定学习深入理解计算机系统之后写一篇博客讨论。</p><p>下面我们来看看一个函数调用会发生什么事情</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int sum(int a, int b)&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    temp = a + b;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 20;</span><br><span class="line">    int c = sum(a,b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">9:        int a = 10;</span><br><span class="line">00401078   mov         dword ptr [ebp-4],0Ah</span><br><span class="line">10:       int b = 20;</span><br><span class="line">0040107F   mov         dword ptr [ebp-8],14h</span><br><span class="line">;以上两句在开辟a，b的空间</span><br><span class="line">11:       int c = sum(a,b);</span><br><span class="line">;然后开始执行这句我们看看发生了什么？</span><br><span class="line">00401086   mov         eax,dword ptr [ebp-8]</span><br><span class="line">;把b的值给eax，然后把eax压栈，由此可以看出，函数调用是从右向左压栈</span><br><span class="line">00401089   push        eax</span><br><span class="line">0040108A   mov         ecx,dword ptr [ebp-4]</span><br><span class="line">0040108D   push        ecx</span><br><span class="line">0040108E   call        @ILT+10(add) (0040100f)</span><br><span class="line">;重点就是这个call指令，他先保存了下一条指令add的地址，为了将来函数调用完成之后可以继续执行下一条</span><br><span class="line">00401093   add         esp,8</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">2:    int sum(int a, int b)&#123;</span><br><span class="line">;一个函数的调用首先会把ebp的值压栈，因为你栈帧回退的时候，你要回到调用者函数的入口</span><br><span class="line">00401020   push        ebp</span><br><span class="line">00401021   mov         ebp,esp ;mov指令把esp的值给ebp，这样ebp就成了被调用函数的栈底指针</span><br><span class="line">00401023   sub         esp,44h ;sub指令把esp的值减44h，等于为被调用的sum函数开辟了44h的空间大小</span><br><span class="line">00401026   push        ebx</span><br><span class="line">00401027   push        esi</span><br><span class="line">00401028   push        edi</span><br><span class="line">;接下来的操作就是在对这个空间的值进行初始化，可以看到全部赋值为0CCCCCCCCh</span><br><span class="line">00401029   lea         edi,[ebp-44h]</span><br><span class="line">0040102C   mov         ecx,11h</span><br><span class="line">00401031   mov         eax,0CCCCCCCCh</span><br><span class="line">00401036   rep stos    dword ptr [edi]</span><br><span class="line">3:        int temp;</span><br><span class="line">4:        temp = a + b;</span><br><span class="line">00401038   mov         eax,dword ptr [ebp+8]</span><br><span class="line">0040103B   add         eax,dword ptr [ebp+0Ch]</span><br><span class="line">0040103E   mov         dword ptr [ebp-4],eax</span><br><span class="line">5:        return temp;</span><br><span class="line">00401041   mov         eax,dword ptr [ebp-4]</span><br><span class="line">6:    &#125;</span><br><span class="line">;我们来看下栈帧回退的过程</span><br><span class="line">00401044   pop         edi</span><br><span class="line">00401045   pop         esi</span><br><span class="line">00401046   pop         ebx</span><br><span class="line">00401047   mov         esp,ebp</span><br><span class="line">;很粗暴，直接把ebp的值给了esp</span><br><span class="line">00401049   pop         ebp</span><br><span class="line">;pop指令把ebp现在指向的值赋给了ebp，现在ebp指向的值就是main函数栈底地址，所以自然回去了</span><br><span class="line">0040104A   ret</span><br><span class="line">;最后的最后执行了add         esp,8，还是很粗暴的方法，由此产生了一个问题？</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">Get</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> *p = Get(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/*打印*p会不会成功呢，答案是会的，从上面的汇编指令可以看出来，你这个并没有释放空间，只是粗暴的把ebp的值给了esp*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="C/C++" scheme="https://kisschina521.github.io/categories/C-C/"/>
    
    
  </entry>
  
  <entry>
    <title>二级指针和字符串数组和命令行参数</title>
    <link href="https://kisschina521.github.io/2019/02/18/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%92%8C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/"/>
    <id>https://kisschina521.github.io/2019/02/18/二级指针和字符串数组和命令行参数/</id>
    <published>2019-02-18T09:04:32.000Z</published>
    <updated>2019-03-10T09:04:51.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>先看以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int ar[10] = &#123;12,23,34,56&#125;;</span><br><span class="line">    sizeof(ar);</span><br><span class="line">    int (&amp;br) [10] = ar;</span><br><span class="line">    int (*p) [10] = &amp;ar;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上三种情况中，数组名都代表数组的类型和大小，在以外的情况中，ar代表首元素的地址，<code>int (&amp;br)[10]</code>代表br是数组ar的一个引用，编译器是这样解释的，br是一个引用，是一个数组类型的引用，数组大小是10，如果不加括号，就会这样解释，开辟十个引用空间，这显然是不合理的，<code>int(*p)[10]</code>也是同样的道理，p是一个指向数组的指针，数组里面有两个属性，一个是存放的类型，一个是数组的大小，在编译时都必须给定。</p><p>除了以上三种情况，数组名都是首元素的地址，他退化成一个指针，并且是一个常性指针，不可以被赋值。</p><p>s与p的差别：</p><p>下面来说说这种<code>int*s[10]</code>这种表示s是一个数组，里面存放了10个int型指针，也就是说对于p来说他开辟4个空间，<code>*p</code>开辟40个空间，对于s来说他开辟40个空间，里面每个元素代表了一个指针，更通俗点来说，p是一个指针，s是一个数组名</p><p>下面来看看图示：</p><p><img src="/2019/02/18/二级指针和字符串数组和命令行参数/test1.png" alt></p><p>有了上面的铺垫，我们来正是探讨二维数组：</p><p><img src="/2019/02/18/二级指针和字符串数组和命令行参数/test2.png" alt></p><p>如果要给ar3的第二个元素赋值<code>*(*(p+2)+1)</code>，相当于<code>p[2][1]</code>，也是相当于这么写<code>*(p[2]+1)</code></p><p> 现在我们再来看一个例子，这个就有点混了，我尽力向大家解释这个东西</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ar[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">sizeof</span>(ar);<span class="comment">//48</span></span><br><span class="line">    <span class="keyword">int</span> (&amp;br) [<span class="number">3</span>][<span class="number">4</span>] = ar;</span><br><span class="line">    <span class="keyword">int</span> (*p) [<span class="number">3</span>][<span class="number">4</span>] = &amp;ar;<span class="comment">//p+1加48个字节</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> (*s) [<span class="number">4</span>] = ar;<span class="comment">//ar+1，加一个数组的大小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最开始的三种情况就回到了我们最开始讨论的那三个情况，ar代表了数组的类型和大小，第4个ar代表了数组的首元素的地址，对于一个二维数组来说，他的首元素代表的就是一个一维数组，所以s+1指向了ar[1]，我们去看汇编源码的时候可以清楚的看到，二维数组也是由一维数组构造的。 ，同理，三维数组也是由二维数组组成的，。</p><p>现在我们来测试一个例子，来看看大家到底有没有理解这块的知识：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ar[<span class="number">5</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>(*p)[<span class="number">2</span>] = &amp;ar[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> *s = ar[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,p[<span class="number">1</span>][<span class="number">3</span>],s[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果会是多少呢？</p><p><code>8,6</code></p><p>因为p是指向一个二维数组第二个元素的地址，所以<code>p[1][3]</code>相当于<code>*((*p+1)+3)</code>，s这个呢相当于<code>*s+3</code>加了3个空间。</p><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;二维数组&quot;&gt;&lt;a href=&quot;#二维数组&quot; class=&quot;headerlink&quot; title=&quot;二维数组&quot;&gt;&lt;/a&gt;二维数组&lt;/h3&gt;&lt;p&gt;先看以下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
      <category term="C/C++" scheme="https://kisschina521.github.io/categories/C-C/"/>
    
    
  </entry>
  
  <entry>
    <title>重新起航</title>
    <link href="https://kisschina521.github.io/2019/02/16/%E9%87%8D%E6%96%B0%E8%B5%B7%E8%88%AA/"/>
    <id>https://kisschina521.github.io/2019/02/16/重新起航/</id>
    <published>2019-02-16T06:34:27.000Z</published>
    <updated>2019-02-16T07:11:07.395Z</updated>
    
    <content type="html"><![CDATA[<p>​    我是个码农，却假装是个程序员，不在浮沙筑高台，不为繁华易匠心，是我的追求，今天是2019年情人节的第二天，我想重新起航。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello world\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    我是个码农，却假装是个程序员，不在浮沙筑高台，不为繁华易匠心，是我的追求，今天是2019年情人节的第二天，我想重新起航。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
      <category term="个人随笔" scheme="https://kisschina521.github.io/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>

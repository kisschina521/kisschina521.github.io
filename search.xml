<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode链表刷题203_141_83_203_206]]></title>
    <url>%2F2019%2F03%2F16%2FLeetCode%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98203-141-83-203-206%2F</url>
    <content type="text"><![CDATA[链表通用数据结构：1234567/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */ 203：请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 现有一个链表 – head = [4,5,1,9]，它可以表示为: 示例 1: 123输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2: 123输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明: 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 1234567void deleteNode(struct ListNode* node) &#123; struct ListNode *p; p = node-&gt;next; node-&gt;val = p-&gt;val; node-&gt;next = p-&gt;next; free(p);&#125; 方法：与下一个节点交换从链表里删除一个节点 node 的最常见方法是修改之前节点的 next 指针，使其指向之后的节点。 因为我们无法访问我们想要删除的节点之前的节点，我们始终不能修改该节点的 next 指针。相反，我们必须将想要删除的节点的值替换为它后面节点中的值，然后删除它之后的节点。 删除的节点不是列表的末尾，所以我们可以保证这种方法是可行的。 此外我们也能看出一点：当你想删除一个节点的时候，你必须知道前一个节点 给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 方法一：哈希表思路 我们可以通过检查一个结点此前是否被访问过来判断链表是否为环形链表。常用的方法是使用哈希表。 算法 我们遍历所有结点并在哈希表中存储每个结点的引用（或内存地址）。如果当前结点为空结点 null（即已检测到链表尾部的下一个结点），那么我们已经遍历完整个链表，并且该链表不是环形链表。如果当前结点的引用已经存在于哈希表中，那么返回 true（即该链表为环形链表）。 123456789101112public boolean hasCycle(ListNode head) &#123; Set&lt;ListNode&gt; nodesSeen = new HashSet&lt;&gt;(); while (head != null) &#123; if (nodesSeen.contains(head)) &#123; return true; &#125; else &#123; nodesSeen.add(head); &#125; head = head.next; &#125; return false;&#125; 复杂度分析 时间复杂度：O(n)O(n)， 对于含有 nn 个元素的链表，我们访问每个元素最多一次。添加一个结点到哈希表中只需要花费 O(1)O(1) 的时间。 空间复杂度：O(n)O(n)， 空间取决于添加到哈希表中的元素数目，最多可以添加 nn 个元素。 方法二：双指针思路 想象一下，两名运动员以不同的速度在环形赛道上跑步会发生什么？ 算法 通过使用具有 不同速度 的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)O(1)。慢指针每次移动一步，而快指针每次移动两步。 如果列表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 false。 现在考虑一个环形链表，把慢指针和快指针想象成两个在环形赛道上跑步的运动员（分别称之为慢跑者与快跑者）。而快跑者最终一定会追上慢跑者。这是为什么呢？考虑下面这种情况（记作情况 A） - 假如快跑者只落后慢跑者一步，在下一次迭代中，它们就会分别跑了一步或两步并相遇。 其他情况又会怎样呢？例如，我们没有考虑快跑者在慢跑者之后两步或三步的情况。但其实不难想到，因为在下一次或者下下次迭代后，又会变成上面提到的情况 A。 123456789101112131415public boolean hasCycle(ListNode head) &#123; if (head == null || head.next == null) &#123; return false; &#125; ListNode slow = head; ListNode fast = head.next; while (slow != fast) &#123; if (fast == null || fast.next == null) &#123; return false; &#125; slow = slow.next; fast = fast.next.next; &#125; return true;&#125; 复杂度分 时间复杂度：O(n)O(n)， 让我们将 nn 设为链表中结点的总数。为了分析时间复杂度，我们分别考虑下面两种情况。 链表中不存在环：快指针将会首先到达尾部，其时间取决于列表的长度，也就是 O(n)O(n)。 链表中存在环：我们将慢指针的移动过程划分为两个阶段：非环部分与环形部分： 慢指针在走完非环部分阶段后将进入环形部分：此时，快指针已经进入环中 \text{迭代次数} = \text{非环部分长度} = N迭代次数=非环部分长度=N 两个指针都在环形区域中：考虑两个在环形赛道上的运动员 - 快跑者每次移动两步而慢跑者每次只移动一步。其速度的差值为1，因此需要经过 \dfrac{\text{二者之间距离}}{\text{速度差值}}速度差值二者之间距离 次循环后，快跑者可以追上慢跑者。这个距离几乎就是 “\text{环形部分长度 K}环形部分长度 K” 且速度差值为 1，我们得出这样的结论 \text{迭代次数} = \text{近似于}迭代次数=近似于 “\text{环形部分长度 K}环形部分长度 K”. 因此，在最糟糕的情形下，时间复杂度为 O(N+K)O(N+K)，也就是 O(n)O(n)。 空间复杂度：O(1)O(1)， 我们只使用了慢指针和快指针两个结点，所以空间复杂度为 O(1)O(1)。 1234567891011121314public class Solution &#123; public boolean hasCycle(ListNode head) &#123; Set&lt;ListNode&gt;node = new HashSet&lt;&gt;(); while(head!=null) &#123; if(node.contains(head)) return true; else node.add(head); head = head.next; &#125; return false; &#125;&#125; 1234567891011121314bool hasCycle(struct ListNode *head) &#123; struct ListNode* fast, *slow; if(head == NULL || head-&gt;next == NULL)&#123; return false; &#125; slow = head; fast = head-&gt;next; while(slow != fast)&#123; if(fast == NULL || fast-&gt;next == NULL) return false; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return true;&#125; 83:给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 12输入: 1-&gt;1-&gt;2输出: 1-&gt;2 示例 2: 12输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3 方法：直接法算法 这是一个简单的问题，仅测试你操作列表的结点指针的能力。由于输入的列表已排序，因此我们可以通过将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。 1234567891011public ListNode deleteDuplicates(ListNode head) &#123; ListNode current = head; while (current != null &amp;&amp; current.next != null) &#123; if (current.next.val == current.val) &#123; current.next = current.next.next; &#125; else &#123; current = current.next; &#125; &#125; return head;&#125; 复杂度分析 时间复杂度：O(n)O(n)，因为列表中的每个结点都检查一次以确定它是否重复，所以总运行时间为 O(n)O(n)，其中 nn 是列表中的结点数。 空间复杂度：O(1)O(1)，没有使用额外的空间。 正确性 我们可以通过定义循环不变式来证明此代码的正确性。循环不变式是在循环的每次迭代之前和之后为真的条件。在这种情况下，一个帮助我们证明正确性的循环不变式是这样的： 列表中直到指针 current 的所有结点都不包含重复的元素。 我们可以用归纳法证明这种情况确实是循环不变式。在进入循环之前，current 指向列表的头部。因此，列表中直到 current 的部分只包含头部。因此它不能包含任何重复的元素。现在假设current 现在指向列表中的某个结点（但不是最后一个元素），并且列表中直到 current 的部分不包含重复元素。在另一个循环迭代之后，发生两件事之一。 current.next 是 current 的副本。在这种情况下，删除 current.next 中的重复结点，并且current保持指向与之前相同的结点。因此，情况仍然成立；一直到 current 仍然没有重复项。 current.next 不是 current 的副本（并且，因为列表已经排序，current.next 也不是 current 之前出现的任何其他元素的副本）。在这种情况下，current 向前移动一步指向 current.next。因此，情况仍然成立；一直到 current 仍然没有重复项。 在循环的最后一次迭代中，current 必定指向最后一个元素，因为再往后，current.next = null。因此，在循环结束后，直到最后一个元素的所有元素都不包含重复项。 123456789101112131415161718192021222324typedef struct ListNode ListNode;struct ListNode* buynode()&#123; struct ListNode* temp = (struct ListNode*)malloc(sizeof(struct ListNode)); return temp;&#125;struct ListNode* deleteDuplicates(struct ListNode* head) &#123; struct ListNode*p = buynode();; p-&gt;next = head; p = p-&gt;next; ListNode* q; while(p &amp;&amp; p-&gt;next != NULL) &#123; if(p-&gt;val == p-&gt;next-&gt;val) &#123; q = p-&gt;next; p-&gt;next = q-&gt;next; free(q); &#125; else p = p-&gt;next; &#125; return head;&#125; p &amp;&amp; p-&gt;next != NULL这句很重要如果前一个条件没有，遍历不到最后一个元素，如果后一个不满足，后一个没有，当p位于最后时q会指向NULL； 206反转一个单链表。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 12345678910111213141516struct ListNode* reverseList(struct ListNode* head) &#123; if(head==NULL) return head; struct ListNode *p,*q,*r; p=head; q=p-&gt;next; head-&gt;next=NULL; while(q!=NULL)&#123; r=q-&gt;next; q-&gt;next=p; p=q; q=r; &#125; head=p; return head;&#125; 主要在于while里面的条件，要遍历所有的节点，思路其实很简单，把头结点独立出来然后头插，所以要有三个指针，p指向头节点，q指向断开后的链表的第一个节点，r在每次循环开始才指向q的下一个，如果r是在循环的末尾指向下一个，当q是最后一个节点时，r是NULL，q = r; r = q-&gt;next就会运行时崩溃。 我的错误示例： 1234567891011121314151617struct ListNode* reverseList(struct ListNode* head) &#123; if(head == NULL) return head; struct ListNode* p,*q,*r; q = head-&gt;next; r = q-&gt;next; head-&gt;next = NULL; p = head; while(q!=NULL)&#123; q-&gt;next = p; p = q; q = r; r = r-&gt;next; &#125; head = p; return head;&#125; 另外这个题还能用递归做： 12345678910// 递归写法，就是在入栈是找到链表的最后一个元素，出栈的时候一点点将链表翻转struct ListNode* reverseList(struct ListNode* head) &#123; if(head == NULL || head -&gt; next == NULL)&#123; // 当 head -&gt; next == node 代表 head 为最后一个节点 return head; &#125; struct ListNode* nHead = reverseList(head -&gt; next); // 循环递归找到最后一个节点 head -&gt; next -&gt; next = head; // 下一个节点（head —&gt; next）的指向（head —&gt; next -&gt; next），指向本节点(head) head -&gt; next = NULL; // 本节点下一个节点想让它等于空，如果本届点不是原头节点，本次的赋值在下次循环中也会被覆盖 return nHead; // 将新的头一层层运出&#125; 以上就是我这周的刷题，速度有点慢，需要加快！！！]]></content>
      <categories>
        <category>Leetcode刷题</category>
      </categories>
      <tags>
        <tag>数据结构与算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链式队列的基本操作和原理]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%92%8C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[进程操作浅析（一）]]></title>
    <url>%2F2019%2F03%2F10%2F%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[fork函数浅析（一）]]></title>
    <url>%2F2019%2F03%2F10%2Ffork%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[进程和程序进程是一个可执行程序的实例，下面引用《Linux系统管理手册中》的一段话： 程序是包含了一系列信息的文件，这些信息描述了如何在运行时创建一个进程，所包括的内容如下： 1. 二进制格式标识 2. 机器语言指令 3. 程序入口地址：标识程序开始执行时的起始指令地址 4. 数据：程序文件包含的变量初始值和程序使用的字面常量值（字符串） 5. 符号表及重定位表：描述程序中函数和变量的位置及名称，可以用来调试和运行时的符号解析（链接） 6. 共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要的共享库，以及加载共享库的动态链接器的路径名 7. 其他信息 可以用一个程序来创建许多进程，或者可以反过来说，许多进程运行的可以是同一程序 所以现在重新给出进程的定义：进程是由内核定义的抽象的实体，并为该实体分配用以执行程序的各项系统资源，从内核角度来看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。 1234567#include &lt;unistd.h&gt;pid_t getpid(void);//得到调用进程idpid_t getppid(void);//得到父进程iduid_t getuid(void);//得到进程的实际用户iduid_t geteuid(void);//调用进程的有效用户idgid_t getgid(void);//调用进程的实际组idgid_t getegid(void);//调用进程的有效组id 如果子进程的父进程终止，子进程会变成孤儿进程，init进程随机收养该进程 函数fork123#include &lt;unishd.h&gt;pid_t fork(void);/*fork函数被调用一次，但返回两次，子进程返回值是0，父进程返回值是子进程的id，理由是一个进程的子进程有很多，并且没有一个函数使一个进程可以获得所有子进程的进程id，子进程返回0的原因，一个进程只有一个父进程，子进程总可以用getppid得到父进程id，id0总是作为内核交换进程使用，所以子进程id不可能为0*/]]></content>
      <categories>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>Linux系统调用 C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据和指令]]></title>
    <url>%2F2019%2F03%2F10%2F%E6%95%B0%E6%8D%AE%E5%92%8C%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718int data1 = 10;int data2 = 0;int data3;static int data4 = 11;static int data5 = 0;static int data6;int main(char argc, char* argv[])&#123; int a = 12; int b = 0; int c; static int e = 13; static int f = 0; static int g; return 0;&#125; 现在思考上面的代码，哪些是指令，哪些是数据呢？ data1，data4，e放在数据段，data2，3，5，6，f，g放在 .bss 段，剩下都是指令放在.text段， .bss放未初始化的全局变量和静态c变量，以及所有被初始化为0的全局或静态变量，在目标文件中.bss不占实际的空间数据放的就是已初始化的全局变量和静态变量，这部分详细的内容，笔者决定学习深入理解计算机系统之后写一篇博客讨论。 下面我们来看看一个函数调用会发生什么事情 12345678910111213#include &lt;stdio.h&gt;int sum(int a, int b)&#123; int temp; temp = a + b; return temp;&#125;int main()&#123; int a = 10; int b = 20; int c = sum(a,b); return 0;&#125; 1234567891011121314159: int a = 10;00401078 mov dword ptr [ebp-4],0Ah10: int b = 20;0040107F mov dword ptr [ebp-8],14h;以上两句在开辟a，b的空间11: int c = sum(a,b);;然后开始执行这句我们看看发生了什么？00401086 mov eax,dword ptr [ebp-8];把b的值给eax，然后把eax压栈，由此可以看出，函数调用是从右向左压栈00401089 push eax0040108A mov ecx,dword ptr [ebp-4]0040108D push ecx0040108E call @ILT+10(add) (0040100f);重点就是这个call指令，他先保存了下一条指令add的地址，为了将来函数调用完成之后可以继续执行下一条00401093 add esp,8 123456789101112131415161718192021222324252627282930312: int sum(int a, int b)&#123;;一个函数的调用首先会把ebp的值压栈，因为你栈帧回退的时候，你要回到调用者函数的入口00401020 push ebp00401021 mov ebp,esp ;mov指令把esp的值给ebp，这样ebp就成了被调用函数的栈底指针00401023 sub esp,44h ;sub指令把esp的值减44h，等于为被调用的sum函数开辟了44h的空间大小00401026 push ebx00401027 push esi00401028 push edi;接下来的操作就是在对这个空间的值进行初始化，可以看到全部赋值为0CCCCCCCCh00401029 lea edi,[ebp-44h]0040102C mov ecx,11h00401031 mov eax,0CCCCCCCCh00401036 rep stos dword ptr [edi]3: int temp;4: temp = a + b;00401038 mov eax,dword ptr [ebp+8]0040103B add eax,dword ptr [ebp+0Ch]0040103E mov dword ptr [ebp-4],eax5: return temp;00401041 mov eax,dword ptr [ebp-4]6: &#125;;我们来看下栈帧回退的过程00401044 pop edi00401045 pop esi00401046 pop ebx00401047 mov esp,ebp;很粗暴，直接把ebp的值给了esp00401049 pop ebp;pop指令把ebp现在指向的值赋给了ebp，现在ebp指向的值就是main函数栈底地址，所以自然回去了0040104A ret;最后的最后执行了add esp,8，还是很粗暴的方法，由此产生了一个问题？ 123456int *Get(int a)&#123; int value = 10; return &amp;value;&#125;int *p = Get(NULL);/*打印*p会不会成功呢，答案是会的，从上面的汇编指令可以看出来，你这个并没有释放空间，只是粗暴的把ebp的值给了esp*/]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二级指针和字符串数组和命令行参数]]></title>
    <url>%2F2019%2F02%2F18%2F%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%92%8C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[二维数组先看以下代码： 123456789#include &lt;stdio.h&gt;int main()&#123; int ar[10] = &#123;12,23,34,56&#125;; sizeof(ar); int (&amp;br) [10] = ar; int (*p) [10] = &amp;ar; return 0;&#125; 以上三种情况中，数组名都代表数组的类型和大小，在以外的情况中，ar代表首元素的地址，int (&amp;br)[10]代表br是数组ar的一个引用，编译器是这样解释的，br是一个引用，是一个数组类型的引用，数组大小是10，如果不加括号，就会这样解释，开辟十个引用空间，这显然是不合理的，int(*p)[10]也是同样的道理，p是一个指向数组的指针，数组里面有两个属性，一个是存放的类型，一个是数组的大小，在编译时都必须给定。 除了以上三种情况，数组名都是首元素的地址，他退化成一个指针，并且是一个常性指针，不可以被赋值。 s与p的差别： 下面来说说这种int*s[10]这种表示s是一个数组，里面存放了10个int型指针，也就是说对于p来说他开辟4个空间，*p开辟40个空间，对于s来说他开辟40个空间，里面每个元素代表了一个指针，更通俗点来说，p是一个指针，s是一个数组名 下面来看看图示： 有了上面的铺垫，我们来正是探讨二维数组： 如果要给ar3的第二个元素赋值*(*(p+2)+1)，相当于p[2][1]，也是相当于这么写*(p[2]+1) 现在我们再来看一个例子，这个就有点混了，我尽力向大家解释这个东西 12345678910#include &lt;stdio.h&gt;int main()&#123; int ar[3][4]; sizeof(ar);//48 int (&amp;br) [3][4] = ar; int (*p) [3][4] = &amp;ar;//p+1加48个字节 int (*s) [4] = ar;//ar+1，加一个数组的大小 return 0;&#125; 最开始的三种情况就回到了我们最开始讨论的那三个情况，ar代表了数组的类型和大小，第4个ar代表了数组的首元素的地址，对于一个二维数组来说，他的首元素代表的就是一个一维数组，所以s+1指向了ar[1]，我们去看汇编源码的时候可以清楚的看到，二维数组也是由一维数组构造的。 ，同理，三维数组也是由二维数组组成的，。 现在我们来测试一个例子，来看看大家到底有没有理解这块的知识： 123456789#include &lt;stdio.h&gt;int main()&#123; int ar[5][2] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; int(*p)[2] = &amp;ar[1]; int *s = ar[1]; printf("%d %d\n",p[1][3],s[3]); return 0;&#125; 打印结果会是多少呢？ 8,6 因为p是指向一个二维数组第二个元素的地址，所以p[1][3]相当于*((*p+1)+3)，s这个呢相当于*s+3加了3个空间。 字符数组]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[重新起航]]></title>
    <url>%2F2019%2F02%2F16%2F%E9%87%8D%E6%96%B0%E8%B5%B7%E8%88%AA%2F</url>
    <content type="text"><![CDATA[​ 我是个码农，却假装是个程序员，不在浮沙筑高台，不为繁华易匠心，是我的追求，今天是2019年情人节的第二天，我想重新起航。 12345#include &lt;stdio.h&gt;int main(void)&#123; printf("Hello world\n");&#125;]]></content>
      <categories>
        <category>个人随笔</category>
      </categories>
  </entry>
</search>
